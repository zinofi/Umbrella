// Copyright (c) Zinofi Digital Ltd. All Rights Reserved.
// Licensed under the MIT License.

using CommunityToolkit.Diagnostics;
using Microsoft.Extensions.Logging;
using System.Reflection;
using Umbrella.Utilities.Exceptions;
using Umbrella.Utilities.Extensions;
using Umbrella.Utilities.Mapping.Abstractions;
using Umbrella.Utilities.Mapping.Mapperly.Abstractions;
using Umbrella.Utilities.Mapping.Mapperly.Options;

namespace Umbrella.Utilities.Mapping.Mapperly;

/// <summary>
/// A very basic implementation of the <see cref="IUmbrellaMapper"/> which uses mapping classes partially generated by the Mapperly source generators internally.
/// </summary>
/// <seealso cref="IUmbrellaMapper" />
public class UmbrellaMapper : IUmbrellaMapper
{
	[AttributeUsage(AttributeTargets.Method)]
	private sealed class PrimaryMappingMethodAttribute : Attribute
	{
	}

	private readonly ILogger _logger;
	private readonly UmbrellaMapperOptions _options;
	private readonly Dictionary<(Type, Type), object> _newInstanceMapperDictionary = new();
	private readonly Dictionary<(Type, Type), object> _newCollectionmapperDictionary = new();
	private readonly Dictionary<(Type, Type), object> _existingInstanceMapperDictionary = new();

	/// <summary>
	/// Initializes a new instance of the <see cref="UmbrellaMapper"/> class.
	/// </summary>
	/// <param name="logger">The logger.</param>
	/// <param name="options">The options.</param>
	public UmbrellaMapper(ILogger<UmbrellaMapper> logger, UmbrellaMapperOptions options)
	{
		_logger = logger;
		_options = options;

		IReadOnlyCollection<Assembly> assembliesToScan = options.TargetAssemblies;

		foreach (Type type in assembliesToScan.SelectMany(x => x.GetExportedTypes()))
		{
			static void PopulateMapperCache(Type type, Type interfaceType, Dictionary<(Type, Type), object> cache)
			{
				Type[] mapperlyInterfaces = type.GetInterfaces().Where(x => x.IsGenericType && x.GetGenericTypeDefinition() == interfaceType).ToArray();

				if (mapperlyInterfaces.Length is 0)
					return;

				foreach (Type mapperlyType in mapperlyInterfaces)
				{
					Type param1 = mapperlyType.GenericTypeArguments[0];
					Type param2 = mapperlyType.GenericTypeArguments[1];

					var key = (param1, param2);

					if (cache.TryGetValue(key, out object? value))
					{
						Type existingType = value.GetType().GenericTypeArguments[0];

						throw new InvalidOperationException($"A registration already exists for the source and destination types. The type being registered is {existingType.FullName} but the type named {type.FullName} has already been registered.");
					}

					cache.Add(key, Activator.CreateInstance(type)!);
				}
			}

			PopulateMapperCache(type, typeof(IUmbrellaMapperlyNewInstanceMapper<,>), _newInstanceMapperDictionary);
			PopulateMapperCache(type, typeof(IUmbrellaMapperlyNewCollectionMapper<,>), _newCollectionmapperDictionary);
			PopulateMapperCache(type, typeof(IUmbrellaMapperlyExistingInstanceMapper<,>), _existingInstanceMapperDictionary);
		}
	}

	/// <inheritdoc />
	public ValueTask<TDestination> MapAsync<TDestination>(object source, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);

		try
		{
			var param1 = source.GetType();
			var param2 = typeof(TDestination);

			MethodInfo miOriginal = GetType().GetMethods().SingleOrDefault(x => x.Name is nameof(MapAsync) && x.GetCustomAttribute<PrimaryMappingMethodAttribute>() is not null)!;
			MethodInfo miGeneric = miOriginal.MakeGenericMethod(param1, param2);

			if (_logger.IsEnabled(LogLevel.Debug))
				_logger.WriteDebug(new { SourceType = param1.FullName, DestinationType = param2.FullName });

			// TODO: We need to cache the generic method we have created above and then use cached compiled expressions
			// to invoke this method instead of using the raw reflection APIs which are slow in comparison.
			return (ValueTask<TDestination>)miGeneric.Invoke(this, new object[] { source, cancellationToken })!;
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = source.GetType().FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc />
	[PrimaryMappingMethod]
	public ValueTask<TDestination> MapAsync<TSource, TDestination>(TSource source, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);

		try
		{
			var param1 = source.GetType();
			var param2 = typeof(TDestination);

			var key = (param1, param2);

			if (!_newInstanceMapperDictionary.TryGetValue(key, out object? value))
			{
				var (isEnumerable, _) = param1.GetIEnumerableTypeData();

				if (isEnumerable)
					throw new InvalidOperationException($"The source type is {param1.FullName} which is a collection. Please call the {nameof(MapAllAsync)} methods to map collections.");

				(isEnumerable, _) = param2.GetIEnumerableTypeData();

				if (isEnumerable)
					throw new InvalidOperationException($"The destination type is {param2.FullName} which is a collection. Please call the {nameof(MapAllAsync)} methods to map collections.");

				throw new InvalidOperationException($"A mapper implementation for the specified source type {param1.FullName} and destination type {param2.FullName} cannot be found.");
			}

			if (value is IUmbrellaMapperlyNewInstanceMapper<TSource, TDestination> mapper)
				return new ValueTask<TDestination>(mapper.Map(source));

			throw new InvalidOperationException("A mapper for the specified source and destination types could not be found.");
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = typeof(TSource).FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc />
	public ValueTask<TDestination> MapAsync<TSource, TDestination>(TSource source, TDestination destination, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);
		Guard.IsNotNull(destination);

		try
		{
			var param1 = source.GetType();
			var param2 = typeof(TDestination);

			var key = (param1, param2);

			if (!_existingInstanceMapperDictionary.TryGetValue(key, out object? value))
				throw new InvalidOperationException($"A mapper implementation for the specified source type {param1.FullName} and destination type {param2.FullName} cannot be found.");

			if (value is IUmbrellaMapperlyExistingInstanceMapper<TSource, TDestination> mapper)
			{
				mapper.Map(source, destination);

				return new ValueTask<TDestination>(destination);
			}

			throw new InvalidOperationException("A mapper for the specified source and destination types could not be found.");
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = typeof(TSource).FullName, DestinationTypeName = typeof(TDestination).FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc/>
	public ValueTask<IReadOnlyCollection<TDestination>> MapAllAsync<TDestination>(IEnumerable<object> source, CancellationToken cancellationToken = default)
	{
		try
		{
			var (isEnumerable, elementType) = source.GetType().GetIEnumerableTypeData();

			if (!isEnumerable)
				throw new InvalidOperationException("The source parameter does not implement IEnumerable.");

			if (elementType is null)
				throw new InvalidOperationException("The elementType of the source collection could not be determined.");

			var type2 = typeof(TDestination);

			MethodInfo miOriginal = GetType().GetMethods().SingleOrDefault(x => x.Name is nameof(MapAllAsync) && x.GetCustomAttribute<PrimaryMappingMethodAttribute>() is not null)!;
			MethodInfo miGeneric = miOriginal?.MakeGenericMethod(elementType, type2)!;

			if (_logger.IsEnabled(LogLevel.Debug))
				_logger.WriteDebug(new { SourceCollectionType = source.GetType().FullName, SourceType = elementType.FullName, DestinationType = type2.FullName });

			//var param1 = Expression.Parameter(source.GetType());
			//var param2 = Expression.Parameter(typeof(CancellationToken));
			//var mce = Expression.Call(Expression.Constant(this), miGeneric, param1, param2);

			//var func = Expression.Lambda<Func<IEnumerable<object>, CancellationToken, ValueTask<IReadOnlyCollection<TDestination>>>>(mce, param1, param2).Compile();

			//return func(source, cancellationToken);

			// TODO: Also need to determine if the cost of creating and caching the delegate outweighs just calling Invoke as per the below.
			// On the server, the benefits are obvious but possibly not so much on the client. Might be a waste of time.
			// Check the fast expression compiler Nuget package too. Might help here.

			// TODO: We need to cache the generic method we have created above and then use cached compiled expressions
			// to invoke this method instead of using the raw reflection APIs which are slow in comparison.
			return (ValueTask<IReadOnlyCollection<TDestination>>)miGeneric.Invoke(this, new object[] { source, cancellationToken })!;
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = source.GetType().FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc/>
	[PrimaryMappingMethod]
	public ValueTask<IReadOnlyCollection<TDestination>> MapAllAsync<TSource, TDestination>(IEnumerable<TSource> source, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);

		try
		{
			var (isEnumerable, elementType) = source.GetType().GetIEnumerableTypeData();

			if (!isEnumerable)
				throw new InvalidOperationException("The source parameter does not implement IEnumerable.");

			if (elementType is null)
				throw new InvalidOperationException("The elementType of the source collection could not be determined.");

			var param2 = typeof(TDestination);

			var key = (elementType, param2);

			if (!_newCollectionmapperDictionary.TryGetValue(key, out object? value))
				throw new InvalidOperationException($"A mapper implementation for the specified source type {elementType.FullName} and destination type {param2.FullName} cannot be found.");

			if (value is IUmbrellaMapperlyNewCollectionMapper<TSource, TDestination> mapper)
				return new ValueTask<IReadOnlyCollection<TDestination>>(mapper.MapAll(source));

			throw new InvalidOperationException("A mapper for the specified source and destination types could not be found.");
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = typeof(TSource).FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}
}