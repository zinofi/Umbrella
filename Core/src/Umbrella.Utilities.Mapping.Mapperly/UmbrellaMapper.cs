using CommunityToolkit.Diagnostics;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System.Reflection;
using Umbrella.Utilities.Exceptions;
using Umbrella.Utilities.Extensions;
using Umbrella.Utilities.Mapping.Abstractions;
using Umbrella.Utilities.Mapping.Mapperly.Abstractions;
using Umbrella.Utilities.Mapping.Mapperly.Options;

namespace Umbrella.Utilities.Mapping.Mapperly;

/// <summary>
/// A very basic implementation of the <see cref="IUmbrellaMapper"/> which uses mapping classes partially generated by the Mapperly source generators internally.
/// </summary>
/// <seealso cref="IUmbrellaMapper" />
public class UmbrellaMapper : IUmbrellaMapper
{
	[AttributeUsage(AttributeTargets.Method)]
	private sealed class PrimaryMappingMethodAttribute : Attribute
	{
	}

	private readonly ILogger _logger;
	private readonly IServiceProvider _serviceProvider;

	// Sync Mappers
	private readonly Dictionary<(Type, Type), object> _newInstanceMapperDictionary = [];
	private readonly Dictionary<(Type, Type), object> _newCollectionMapperDictionary = [];
	private readonly Dictionary<(Type, Type), object> _existingInstanceMapperDictionary = [];

	// Async Mappers
	private readonly Dictionary<(Type, Type), object> _newInstanceAsyncMapperDictionary = [];
	private readonly Dictionary<(Type, Type), object> _newCollectionAsyncMapperDictionary = [];
	private readonly Dictionary<(Type, Type), object> _existingInstanceAsyncMapperDictionary = [];

	/// <summary>
	/// Initializes a new instance of the <see cref="UmbrellaMapper"/> class.
	/// </summary>
	/// <param name="logger">The logger.</param>
	/// <param name="options">The options.</param>
	/// <param name="serviceProvider">The service provider.</param>
	public UmbrellaMapper(
		ILogger<UmbrellaMapper> logger,
		UmbrellaMapperOptions options,
		IServiceProvider serviceProvider)
	{
		Guard.IsNotNull(options);
		Guard.IsNotNull(serviceProvider);

		_logger = logger;
		_serviceProvider = serviceProvider;

		IReadOnlyCollection<Assembly> assembliesToScan = options.TargetAssemblies is { Count: > 0 }
			? options.TargetAssemblies
			: AppDomain.CurrentDomain.GetAssemblies().Where(x => x.FullName?.StartsWith(options.TargetAssemblyNamePrefix ?? string.Empty, StringComparison.OrdinalIgnoreCase) ?? false).ToArray();

		foreach (Type type in assembliesToScan.SelectMany(x => x.GetExportedTypes()))
		{
			void PopulateMapperCache(Type type, Type interfaceType, Dictionary<(Type, Type), object> cache)
			{
				Type[] mapperlyInterfaces = type.GetInterfaces().Where(x => x.IsGenericType && x.GetGenericTypeDefinition() == interfaceType).ToArray();

				if (mapperlyInterfaces.Length is 0)
					return;

				foreach (Type mapperlyType in mapperlyInterfaces)
				{
					Type param1 = mapperlyType.GenericTypeArguments[0];
					Type param2 = mapperlyType.GenericTypeArguments[1];

					var key = (param1, param2);

					if (cache.TryGetValue(key, out object? value))
					{
						Type existingType = value.GetType().GenericTypeArguments[0];

						throw new InvalidOperationException($"A registration already exists for the source and destination types. The type being registered is {existingType.FullName} but the type named {type.FullName} has already been registered.");
					}

					cache.Add(key, ActivatorUtilities.CreateInstance(_serviceProvider, type));
				}
			}

			// Sync Mappers
			PopulateMapperCache(type, typeof(IUmbrellaMapperlyNewInstanceMapper<,>), _newInstanceMapperDictionary);
			PopulateMapperCache(type, typeof(IUmbrellaMapperlyNewCollectionMapper<,>), _newCollectionMapperDictionary);
			PopulateMapperCache(type, typeof(IUmbrellaMapperlyExistingInstanceMapper<,>), _existingInstanceMapperDictionary);

			// Async Mappers
			PopulateMapperCache(type, typeof(IUmbrellaMapperlyNewInstanceAsyncMapper<,>), _newInstanceAsyncMapperDictionary);
			PopulateMapperCache(type, typeof(IUmbrellaMapperlyNewCollectionAsyncMapper<,>), _newCollectionAsyncMapperDictionary);
			PopulateMapperCache(type, typeof(IUmbrellaMapperlyExistingInstanceAsyncMapper<,>), _existingInstanceAsyncMapperDictionary);
		}
	}

	/// <inheritdoc />
	public ValueTask<TDestination> MapAsync<TDestination>(object source, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);

		try
		{
			var param1 = source.GetType().GetOriginalType();
			Guard.IsNotNull(param1);

			var param2 = typeof(TDestination);

			MethodInfo miOriginal = GetType().GetMethods().SingleOrDefault(x => x.Name is nameof(MapAsync) && x.GetCustomAttribute<PrimaryMappingMethodAttribute>() is not null)!;
			MethodInfo miGeneric = miOriginal.MakeGenericMethod(param1, param2);

			if (_logger.IsEnabled(LogLevel.Debug))
				_logger.WriteDebug(new { SourceType = param1.FullName, DestinationType = param2.FullName });

			// TODO: We need to cache the generic method we have created above and then use cached compiled expressions
			// to invoke this method instead of using the raw reflection APIs which are slow in comparison.
			return (ValueTask<TDestination>)miGeneric.Invoke(this, [source, cancellationToken])!;
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = source.GetType().FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc />
	[PrimaryMappingMethod]
	public async ValueTask<TDestination> MapAsync<TSource, TDestination>(TSource source, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);

		try
		{
			var param1 = source.GetType().GetOriginalType();
			Guard.IsNotNull(param1);

			var param2 = typeof(TDestination);

			var key = (param1, param2);

			if (!_newInstanceAsyncMapperDictionary.TryGetValue(key, out object? value) && !_newInstanceMapperDictionary.TryGetValue(key, out value))
			{
				var (isEnumerable, _) = param1.GetIEnumerableTypeData();

				if (isEnumerable)
					throw new InvalidOperationException($"The source type is {param1.FullName} which is a collection. Please call the {nameof(MapAllAsync)} methods to map collections.");

				(isEnumerable, _) = param2.GetIEnumerableTypeData();

				if (isEnumerable)
					throw new InvalidOperationException($"The destination type is {param2.FullName} which is a collection. Please call the {nameof(MapAllAsync)} methods to map collections.");

				throw new InvalidOperationException($"A mapper implementation for the specified source type {param1.FullName} and destination type {param2.FullName} cannot be found when trying to map to a new instance.");
			}

			return value switch
			{
				IUmbrellaMapperlyNewInstanceAsyncMapper<TSource, TDestination> asyncMapper => await asyncMapper.MapAsync(source, cancellationToken).ConfigureAwait(false),
				IUmbrellaMapperlyNewInstanceMapper<TSource, TDestination> mapper => mapper.Map(source),
				_ => throw new InvalidOperationException("A mapper for the specified source and destination types could not be found.")
			};
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = typeof(TSource).FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc />
	public async ValueTask<TDestination> MapAsync<TSource, TDestination>(TSource source, TDestination destination, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);
		Guard.IsNotNull(destination);

		try
		{
			var param1 = source.GetType().GetOriginalType();
			Guard.IsNotNull(param1);

			var param2 = typeof(TDestination);

			var key = (param1, param2);

			if (!_existingInstanceAsyncMapperDictionary.TryGetValue(key, out object? value) && !_existingInstanceMapperDictionary.TryGetValue(key, out value))
				throw new InvalidOperationException($"A mapper implementation for the specified source type {param1.FullName} and destination type {param2.FullName} cannot be found when trying to map to an existing instance.");

			if (value is IUmbrellaMapperlyExistingInstanceAsyncMapper<TSource, TDestination> asyncMapper)
			{
				await asyncMapper.MapAsync(source, destination, cancellationToken).ConfigureAwait(false);

				return destination;
			}

			if (value is IUmbrellaMapperlyExistingInstanceMapper<TSource, TDestination> mapper)
			{
				mapper.Map(source, destination);

				return destination;
			}

			throw new InvalidOperationException("A mapper for the specified source and destination types could not be found.");
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = typeof(TSource).FullName, DestinationTypeName = typeof(TDestination).FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc/>
	public ValueTask<IReadOnlyCollection<TDestination>> MapAllAsync<TDestination>(IEnumerable<object> source, CancellationToken cancellationToken = default)
	{
		Guard.IsNotNull(source);

		try
		{
			var (isEnumerable, elementType) = source.GetType().GetIEnumerableTypeData();

			if (!isEnumerable)
				throw new InvalidOperationException("The source parameter does not implement IEnumerable.");

			if (elementType is null)
				throw new InvalidOperationException("The elementType of the source collection could not be determined.");

			elementType = elementType.GetOriginalType();

			if (elementType is null)
				throw new InvalidOperationException("The elementType of the source collection could not be determined.");

			var type2 = typeof(TDestination);

			MethodInfo miOriginal = GetType().GetMethods().SingleOrDefault(x => x.Name is nameof(MapAllAsync) && x.GetCustomAttribute<PrimaryMappingMethodAttribute>() is not null)!;
			MethodInfo miGeneric = miOriginal?.MakeGenericMethod(elementType, type2)!;

			if (_logger.IsEnabled(LogLevel.Debug))
				_logger.WriteDebug(new { SourceCollectionType = source.GetType().FullName, SourceType = elementType.FullName, DestinationType = type2.FullName });

			//var param1 = Expression.Parameter(source.GetType());
			//var param2 = Expression.Parameter(typeof(CancellationToken));
			//var mce = Expression.Call(Expression.Constant(this), miGeneric, param1, param2);

			//var func = Expression.Lambda<Func<IEnumerable<object>, CancellationToken, ValueTask<IReadOnlyCollection<TDestination>>>>(mce, param1, param2).Compile();

			//return func(source, cancellationToken);

			// TODO: Also need to determine if the cost of creating and caching the delegate outweighs just calling Invoke as per the below.
			// On the server, the benefits are obvious but possibly not so much on the client. Might be a waste of time.
			// Check the fast expression compiler Nuget package too. Might help here.

			// TODO: We need to cache the generic method we have created above and then use cached compiled expressions
			// to invoke this method instead of using the raw reflection APIs which are slow in comparison.
			return (ValueTask<IReadOnlyCollection<TDestination>>)miGeneric.Invoke(this, [source, cancellationToken])!;
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = source.GetType().FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc/>
	[PrimaryMappingMethod]
	public async ValueTask<IReadOnlyCollection<TDestination>> MapAllAsync<TSource, TDestination>(IEnumerable<TSource> source, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);

		try
		{
			var (isEnumerable, elementType) = source.GetType().GetIEnumerableTypeData();

			if (!isEnumerable)
				throw new InvalidOperationException("The source parameter does not implement IEnumerable.");

			if (elementType is null)
				throw new InvalidOperationException("The elementType of the source collection could not be determined.");

			elementType = elementType.GetOriginalType();

			if (elementType is null)
				throw new InvalidOperationException("The elementType of the source collection could not be determined.");

			var param2 = typeof(TDestination);

			var key = (elementType, param2);

			if (!_newCollectionAsyncMapperDictionary.TryGetValue(key, out object? value) && !_newCollectionMapperDictionary.TryGetValue(key, out value))
				throw new InvalidOperationException($"A mapper implementation for the specified source type {elementType.FullName} and destination type {param2.FullName} cannot be found when trying to map to a new collection.");

			return value switch
			{
				IUmbrellaMapperlyNewCollectionAsyncMapper<TSource, TDestination> asyncMapper => await asyncMapper.MapAllAsync(source, cancellationToken).ConfigureAwait(false),
				IUmbrellaMapperlyNewCollectionMapper<TSource, TDestination> mapper => mapper.MapAll(source),
				_ => throw new InvalidOperationException("A mapper for the specified source and destination types could not be found.")
			};
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = typeof(TSource).FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}
}