// Copyright (c) Zinofi Digital Ltd. All Rights Reserved.
// Licensed under the MIT License.

using CommunityToolkit.Diagnostics;
using Microsoft.Extensions.Logging;
using Riok.Mapperly.Abstractions;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Reflection;
using Umbrella.Utilities.Exceptions;
using Umbrella.Utilities.Extensions;
using Umbrella.Utilities.Mapping.Abstractions;

namespace Umbrella.Utilities.Mapping.Mapperly;

/// <summary>
/// A very basic implementation of the <see cref="IUmbrellaMapper"/> which uses mapping classes partially generated by the Mapperly source generators internally.
/// </summary>
/// <seealso cref="IUmbrellaMapper" />
public class UmbrellaMapper : IUmbrellaMapper
{
	private readonly ILogger _logger;
	private readonly Dictionary<(Type, Type), Lazy<object>> _mapperDictionary = new();

	/// <summary>
	/// Initializes a new instance of the <see cref="UmbrellaMapper"/> class.
	/// </summary>
	/// <param name="logger">The logger.</param>
	/// <param name="options">The options.</param>
	public UmbrellaMapper(ILogger<UmbrellaMapper> logger, UmbrellaMapperOptions options)
	{
		_logger = logger;

		IReadOnlyCollection<Assembly> assembliesToScan = options.TargetAssemblies;

		Dictionary<(Type, Type), Type> dicTypeMapping = new();

		foreach (Type type in assembliesToScan.SelectMany(x => x.GetExportedTypes()))
		{
			Type? mapperlyInterface = type.GetInterfaces().SingleOrDefault(x => x == typeof(IUmbrellaMapperlyMapper<,>));

			if (mapperlyInterface is null)
				continue;

			Type param1 = mapperlyInterface.GenericTypeArguments[0];
			Type param2 = mapperlyInterface.GenericTypeArguments[1];

			var key = (param1, param2);

			if (dicTypeMapping.ContainsKey(key))
			{
				Type currentlyRegisteredType = dicTypeMapping[key];

				throw new Exception($"A registration already exists for the source and destination types. The type being registered is {currentlyRegisteredType.FullName} but the type named {type.FullName} has already been registered.");
			}

			dicTypeMapping.Add(key, type);
			_mapperDictionary.Add(key, new Lazy<object>(() => Activator.CreateInstance(type)));
		}
	}

	/// <inheritdoc />
	public ValueTask<TDestination> MapAsync<TDestination>(object source, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);

		try
		{
			var param1 = source.GetType();
			var param2 = typeof(TDestination);

			//var key = (param1, param2);

			//if (!_mapperDictionary.TryGetValue(key, out var value))
			//	throw new Exception($"A mapper implementation for the specified source type {param1.FullName} and destination type {param2.FullName} cannot be found.");

			//var targetType = typeof(IUmbrellaMapperlyMapper<,>).MakeGenericType(param1, param2);
			//var mapperType = value.Value.GetType();

			//if (!targetType.IsAssignableFrom(mapperType))
			//	throw new Exception($"The mapper type {mapperType.FullName} to map from {param1.FullName} to {param2.FullName} cannot be assigned to a the type {targetType.FullName}");

			MethodInfo miOriginal = GetType().GetMethods().SingleOrDefault(x => x.Name == nameof(MapAsync) && x.GetParameters().Length is 2 && x.GetParameters()[0].ParameterType != typeof(object));
			MethodInfo miGeneric = miOriginal.MakeGenericMethod(param1, param2);

			// TODO: We need to cache the generic method we have created above and then use cached compiled expressions
			// to invoke this method instead of using the raw reflection APIs which are slow in comparison.
			return (ValueTask<TDestination>)miGeneric.Invoke(this, new object[] { source, cancellationToken });
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = source?.GetType().FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc />
	public ValueTask<TDestination> MapAsync<TSource, TDestination>(TSource source, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);

		try
		{
			var param1 = source.GetType();
			var param2 = typeof(TDestination);

			var key = (param1, param2);

			if (!_mapperDictionary.TryGetValue(key, out var value))
				throw new Exception($"A mapper implementation for the specified source type {param1.FullName} and destination type {param2.FullName} cannot be found.");

			if (value.Value is IUmbrellaMapperlyMapper<TSource, TDestination> mapper)
				return new ValueTask<TDestination>(mapper.Map(source));

			throw new Exception("A mapper for the specified source and destination types could not be found.");
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = typeof(TSource).FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc />
	public ValueTask<TDestination> MapAsync<TSource, TDestination>(TSource source, TDestination destination, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		Guard.IsNotNull(source);
		Guard.IsNotNull(destination);

		try
		{
			var param1 = source.GetType();
			var param2 = typeof(TDestination);

			var key = (param1, param2);

			if (!_mapperDictionary.TryGetValue(key, out var value))
				throw new Exception($"A mapper implementation for the specified source type {param1.FullName} and destination type {param2.FullName} cannot be found.");

			if (value.Value is IUmbrellaMapperlyMapper<TSource, TDestination> mapper)
			{
				mapper.Map(source, destination);

				return new ValueTask<TDestination>(destination);
			}

			throw new Exception("A mapper for the specified source and destination types could not be found.");
		}
		catch (Exception exc) when (_logger.WriteError(exc, new { SourceTypeName = typeof(TSource).FullName, DestinationTypeName = typeof(TDestination).FullName }))
		{
			throw new UmbrellaMappingException("There has been a problem mapping the object.", exc);
		}
	}

	/// <inheritdoc/>
	public ValueTask<IReadOnlyCollection<TDestination>> MapAllAsync<TDestination>(IEnumerable<object> source, CancellationToken cancellationToken)
	{
		throw new NotImplementedException();
	}

	/// <inheritdoc/>
	public ValueTask<IReadOnlyCollection<TDestination>> MapAllAsync<TSource, TDestination>(IEnumerable<TSource> source, CancellationToken cancellationToken)
	{
		throw new NotImplementedException();
	}
}