using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

[Generator]
public class TrimmableSourceGenerator : ISourceGenerator
{
    private const string InterfaceName = "StringTrimmer.ITrimmable";
    
    public void Initialize(GeneratorInitializationContext context)
    {
        // Generate the interface first
        context.RegisterForPostInitialization(ctx => GenerateInterface(ctx));
        context.RegisterForSyntaxNotifications(() => new TrimmableSyntaxReceiver());
    }

    private void GenerateInterface(GeneratorPostInitializationContext context)
    {
        var interfaceSource = @"// <auto-generated />
namespace StringTrimmer
{
    /// <summary>
    /// Interface for types that support automatic trimming of string properties.
    /// </summary>
    public interface ITrimmable
    {
        /// <summary>
        /// Trims all string properties in this object and its nested properties.
        /// </summary>
        void TrimAllStringProperties();
    }
}";
        context.AddSource("ITrimmable.g.cs", SourceText.From(interfaceSource, Encoding.UTF8));
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (!(context.SyntaxReceiver is TrimmableSyntaxReceiver receiver))
            return;

        var compilation = context.Compilation;
        var trimmableSymbol = compilation.GetTypeByMetadataName(InterfaceName);
        
        if (trimmableSymbol == null)
            return;

        foreach (var candidateClass in receiver.CandidateClasses)
        {
            var model = compilation.GetSemanticModel(candidateClass.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(candidateClass) as INamedTypeSymbol;
            
            if (classSymbol == null)
                continue;

            if (ImplementsInterface(classSymbol, trimmableSymbol))
            {
                var source = GenerateTrimmableImplementation(classSymbol, compilation);
                context.AddSource($"{classSymbol.Name}_Trimmable.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private bool ImplementsInterface(INamedTypeSymbol classSymbol, INamedTypeSymbol interfaceSymbol)
    {
        return classSymbol.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, interfaceSymbol));
    }

    private string GenerateTrimmableImplementation(INamedTypeSymbol classSymbol, Compilation compilation)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var trimmableSymbol = compilation.GetTypeByMetadataName(InterfaceName);
        
        var trimStatements = GenerateTrimStatements(classSymbol, "this", new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default), trimmableSymbol);

        var statementsText = trimStatements.Any() 
            ? string.Join("\n", trimStatements.Select(s => $"            {s}"))
            : "            // No string properties found to trim";

        return $@"// <auto-generated />
#nullable enable
using System;

namespace {namespaceName}
{{
    partial class {className}
    {{
        /// <summary>
        /// Trims all string properties in this object and its nested properties.
        /// Generated by StringTrimmer Source Generator.
        /// Uses modern C# pattern matching for robust null checking.
        /// </summary>
        public void TrimAllStringProperties()
        {{
{statementsText}
        }}
    }}
}}";
    }

    private List<string> GenerateTrimStatements(INamedTypeSymbol typeSymbol, string instanceName, HashSet<INamedTypeSymbol> visitedTypes, INamedTypeSymbol trimmableInterface)
    {
        var statements = new List<string>();
        
        // Prevent infinite recursion
        if (visitedTypes.Contains(typeSymbol))
            return statements;
        
        visitedTypes.Add(typeSymbol);

        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is IPropertySymbol property && 
                property.SetMethod != null && 
                !property.SetMethod.IsInitOnly &&
                property.GetMethod != null &&
                property.DeclaredAccessibility == Accessibility.Public)
            {
                var propertyName = property.Name;
                var propertyType = property.Type;

                // Handle string properties (both nullable and non-nullable)
                if (propertyType.SpecialType == SpecialType.System_String)
                {
                    // Use null propagation for string trimming - this is safe as strings don't typically override operators
                    statements.Add($"{instanceName}.{propertyName} = {instanceName}.{propertyName}?.Trim();");
                }
                // Handle complex properties
                else if (propertyType is INamedTypeSymbol namedPropertyType && 
                         !IsSystemType(namedPropertyType) && 
                         !namedPropertyType.IsValueType)
                {
                    // Check if the nested type implements ITrimmable
                    if (ImplementsInterface(namedPropertyType, trimmableInterface))
                    {
                        // Use null propagation to call TrimAllStringProperties
                        statements.Add($"{instanceName}.{propertyName}?.TrimAllStringProperties();");
                    }
                    else
                    {
                        // For non-ITrimmable types, use pattern matching for robust null checking
                        var nestedStatements = GenerateTrimStatements(namedPropertyType, $"{instanceName}.{propertyName}", new HashSet<INamedTypeSymbol>(visitedTypes), trimmableInterface);
                        
                        if (nestedStatements.Any())
                        {
                            statements.Add($"if ({instanceName}.{propertyName} is not null)");
                            statements.Add($"{{");
                            statements.AddRange(nestedStatements.Select(s => $"    {s}"));
                            statements.Add($"}}");
                        }
                    }
                }
                // Handle collections and arrays
                else if (IsCollectionType(propertyType))
                {
                    var elementType = GetCollectionElementType(propertyType);
                    if (elementType != null)
                    {
                        if (elementType.SpecialType == SpecialType.System_String)
                        {
                            // Handle collections of strings
                            statements.Add($"if ({instanceName}.{propertyName} is not null)");
                            statements.Add($"{{");
                            statements.Add($"    for (int i = 0; i < {instanceName}.{propertyName}.Count; i++)");
                            statements.Add($"    {{");
                            statements.Add($"        {instanceName}.{propertyName}[i] = {instanceName}.{propertyName}[i]?.Trim();");
                            statements.Add($"    }}");
                            statements.Add($"}}");
                        }
                        else if (elementType is INamedTypeSymbol namedElementType && 
                                 !IsSystemType(namedElementType) && 
                                 ImplementsInterface(namedElementType, trimmableInterface))
                        {
                            // Handle collections of ITrimmable objects
                            statements.Add($"if ({instanceName}.{propertyName} is not null)");
                            statements.Add($"{{");
                            statements.Add($"    foreach (var item in {instanceName}.{propertyName})");
                            statements.Add($"    {{");
                            statements.Add($"        item?.TrimAllStringProperties();");
                            statements.Add($"    }}");
                            statements.Add($"}}");
                        }
                    }
                }
            }
        }

        visitedTypes.Remove(typeSymbol);
        return statements;
    }

    private bool IsSystemType(INamedTypeSymbol type)
    {
        var namespaceName = type.ContainingNamespace?.ToDisplayString();
        return namespaceName?.StartsWith("System") == true ||
               namespaceName?.StartsWith("Microsoft") == true;
    }

    private bool IsCollectionType(ITypeSymbol type)
    {
        if (type is IArrayTypeSymbol)
            return true;

        if (type is INamedTypeSymbol namedType)
        {
            // Check for common collection interfaces
            var collectionInterfaces = new[]
            {
                "System.Collections.Generic.IList",
                "System.Collections.Generic.ICollection",
                "System.Collections.Generic.IEnumerable"
            };

            return namedType.AllInterfaces.Any(i => 
                collectionInterfaces.Any(ci => i.ToDisplayString().StartsWith(ci)));
        }

        return false;
    }

    private ITypeSymbol GetCollectionElementType(ITypeSymbol type)
    {
        if (type is IArrayTypeSymbol arrayType)
            return arrayType.ElementType;

        if (type is INamedTypeSymbol namedType && namedType.TypeArguments.Length > 0)
            return namedType.TypeArguments[0];

        return null;
    }
}

internal class TrimmableSyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
            classDeclaration.BaseList?.Types.Any() == true)
        {
            CandidateClasses.Add(classDeclaration);
        }
    }
}