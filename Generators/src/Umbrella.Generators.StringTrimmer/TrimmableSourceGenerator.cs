using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Umbrella.Generators.StringTrimmer;

/// <summary>
/// A source generator that automatically implements the IUmbrellaTrimmable interface
/// </summary>
[Generator]
public class TrimmableSourceGenerator : IIncrementalGenerator
{
	// Updated fully qualified name
	private const string InterfaceName = "Umbrella.Utilities.Text.IUmbrellaTrimmable";

	/// <inheritdoc />
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Removed: Do NOT emit the interface, it will be supplied by the user's codebase

		// Find candidate classes
		var classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (syntaxNode, _) => IsCandidate(syntaxNode),
				transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
			.Where(static cls => cls is not null);

		// Combine class with semantic model and compilation
		var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

		// Register for output
		context.RegisterSourceOutput(compilationAndClasses, static (spc, source) =>
		{
			var (compilation, classList) = source;
			var trimmableSymbol = compilation.GetTypeByMetadataName(InterfaceName);

			if (trimmableSymbol is null)
				return;

			foreach (var classDeclaration in classList.Distinct())
			{
				var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

				if (model.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
					continue;

				if (ImplementsInterface(classSymbol, trimmableSymbol))
				{
					string generated = GenerateTrimmableImplementation(classSymbol, trimmableSymbol);
					spc.AddSource($"{classSymbol.Name}_UmbrellaTrimmable.g.cs", SourceText.From(generated, Encoding.UTF8));
				}
			}
		});
	}

	private static bool IsCandidate(SyntaxNode node)
		=> node is ClassDeclarationSyntax cds && cds.BaseList?.Types.Any() == true;

	private static bool ImplementsInterface(INamedTypeSymbol classSymbol, INamedTypeSymbol interfaceSymbol)
		=> classSymbol.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, interfaceSymbol));

	private static string GenerateTrimmableImplementation(
		INamedTypeSymbol classSymbol,
		INamedTypeSymbol trimmableSymbol)
	{
		string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
		string className = classSymbol.Name;

		var trimStatements = GenerateTrimStatements(classSymbol, "this", new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default), trimmableSymbol);

		string statementsText = trimStatements.Any()
			? string.Join("\n", trimStatements.Select(s => $"            {s}"))
			: "            // No string properties found to trim";

		return $$"""
				// <auto-generated />
				#nullable enable
				using System;

				namespace {{namespaceName}}
				{
					partial class {{className}}
					{
						/// <summary>
						/// Trims all string properties in this object and its nested properties.
						/// </summary>
						public void TrimAllStringProperties()
						{
							{{statementsText}}
						}
					}
				}
				""";
	}

	private static List<string> GenerateTrimStatements(
		INamedTypeSymbol typeSymbol,
		string instanceName,
		HashSet<INamedTypeSymbol> visitedTypes,
		INamedTypeSymbol trimmableInterface)
	{
		var statements = new List<string>();

		// Prevent infinite recursion
		if (visitedTypes.Contains(typeSymbol))
			return statements;

		_ = visitedTypes.Add(typeSymbol);

		foreach (var member in typeSymbol.GetMembers())
		{
			if (member is IPropertySymbol property &&
				property.SetMethod is not null &&
				!property.SetMethod.IsInitOnly &&
				property.GetMethod is not null &&
				property.DeclaredAccessibility is Accessibility.Public)
			{
				string propertyName = property.Name;
				var propertyType = property.Type;

				// Handle string properties (both nullable and non-nullable)
				if (propertyType.SpecialType == SpecialType.System_String)
				{
					statements.Add($"{instanceName}.{propertyName} = {instanceName}.{propertyName}?.Trim();");
				}
				// Handle complex properties
				else if (propertyType is INamedTypeSymbol namedPropertyType &&
						 !IsSystemType(namedPropertyType) &&
						 !namedPropertyType.IsValueType)
				{
					// Check if the nested type implements IUmbrellaTrimmable
					if (ImplementsInterface(namedPropertyType, trimmableInterface))
					{
						statements.Add($"{instanceName}.{propertyName}?.TrimAllStringProperties();");
					}
					else
					{
						var nestedStatements = GenerateTrimStatements(
							namedPropertyType,
							$"{instanceName}.{propertyName}",
							[.. visitedTypes],
							trimmableInterface);

						if (nestedStatements.Any())
						{
							statements.Add($$"""
								if ({{instanceName}}.{{propertyName}} is not null)
								{
									{{string.Join("\n", nestedStatements.Select(s => $"    {s}"))}}
								}
								""");
						}
					}
				}
				// Handle collections and arrays
				else if (IsCollectionType(propertyType))
				{
					var elementType = GetCollectionElementType(propertyType);
					if (elementType is not null)
					{
						if (elementType.SpecialType == SpecialType.System_String)
						{
							statements.Add($$"""
									if ({{instanceName}}.{{propertyName}} is not null)
									{
										for (int i = 0; i < {{instanceName}}.{{propertyName}}.Count; i++)
										{
											{{instanceName}}.{{propertyName}}[i] = {{instanceName}}.{{propertyName}}[i]?.Trim();
										}
									}
									""");
						}
						else if (elementType is INamedTypeSymbol namedElementType &&
								 !IsSystemType(namedElementType) &&
								 ImplementsInterface(namedElementType, trimmableInterface))
						{
							statements.Add($$"""
									if ({{instanceName}}.{{propertyName}} is not null)
									{
										foreach (var item in {{instanceName}}.{{propertyName}})
										{
											item?.TrimAllStringProperties();
										}
									}
									""");
						}
					}
				}
			}
		}

		_ = visitedTypes.Remove(typeSymbol);

		return statements;
	}

	private static bool IsSystemType(INamedTypeSymbol type)
	{
		string? namespaceName = type.ContainingNamespace?.ToDisplayString();

		return namespaceName?.StartsWith("System", StringComparison.Ordinal) is true ||
			   namespaceName?.StartsWith("Microsoft", StringComparison.Ordinal) is true;
	}

	private static bool IsCollectionType(ITypeSymbol type)
	{
		if (type is IArrayTypeSymbol)
			return true;

		if (type is INamedTypeSymbol namedType)
		{
			string[] collectionInterfaces =
			[
				"System.Collections.Generic.IList",
				"System.Collections.Generic.ICollection",
				"System.Collections.Generic.IEnumerable"
			];

			return namedType.AllInterfaces.Any(i =>
				collectionInterfaces.Any(ci => i.ToDisplayString().StartsWith(ci, StringComparison.Ordinal)));
		}

		return false;
	}

	private static ITypeSymbol? GetCollectionElementType(ITypeSymbol type)
	{
		if (type is IArrayTypeSymbol arrayType)
			return arrayType.ElementType;

		if (type is INamedTypeSymbol namedType && namedType.TypeArguments.Length > 0)
			return namedType.TypeArguments[0];

		return null;
	}
}