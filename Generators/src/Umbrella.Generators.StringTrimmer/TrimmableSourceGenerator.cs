using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Umbrella.Generators.StringTrimmer;

/// <summary>
/// A source generator that automatically implements the IUmbrellaTrimmable interface
/// </summary>
[Generator]
public class TrimmableSourceGenerator : IIncrementalGenerator
{
	private const string InterfaceName = "Umbrella.Utilities.Text.IUmbrellaTrimmable";

	/// <inheritdoc />
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (syntaxNode, _) => IsCandidate(syntaxNode),
				transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
			.Where(static cls => cls is not null);

		var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

		context.RegisterSourceOutput(compilationAndClasses, static (spc, source) =>
		{
			var (compilation, classList) = source;
			var trimmableSymbol = compilation.GetTypeByMetadataName(InterfaceName);

			if (trimmableSymbol is null)
				return;

			foreach (var classDeclaration in classList.Distinct())
			{
				var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

				if (model.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
					continue;

				if (ImplementsInterface(classSymbol, trimmableSymbol))
				{
					string generated = GenerateTrimmableImplementation(classSymbol, trimmableSymbol);
					spc.AddSource($"{classSymbol.Name}_UmbrellaTrimmable.g.cs", SourceText.From(generated, Encoding.UTF8));
				}
			}
		});
	}

	private static bool IsCandidate(SyntaxNode node)
		=> node is ClassDeclarationSyntax cds && cds.BaseList?.Types.Any() == true;

	private static bool ImplementsInterface(INamedTypeSymbol classSymbol, INamedTypeSymbol interfaceSymbol)
		=> classSymbol.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, interfaceSymbol));

	private static string GenerateTrimmableImplementation(
		INamedTypeSymbol classSymbol,
		INamedTypeSymbol trimmableSymbol)
	{
		string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
		string className = classSymbol.Name;

		var trimStatements = GenerateTrimStatements(classSymbol, "this", new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default), trimmableSymbol, 0);

		string statementsText = trimStatements.Any()
			? string.Join("\n", trimStatements.Select(s => $"\t\t\t{s}"))
			: "\t\t\t// No string properties found to trim";

		return $$"""
		// <auto-generated />
		#nullable enable
		using System;
		
		namespace {{namespaceName}}
		{
			partial class {{className}}
			{
				private bool _isTrimmingInProgress;

				/// <summary>
				/// Trims all string properties in this object and its nested properties.
				/// </summary>
				public void TrimAllStringProperties()
				{
					if (_isTrimmingInProgress)
						return;

					try
					{
						_isTrimmingInProgress = true;
		{{statementsText}}
					}
					finally
					{
						_isTrimmingInProgress = false;
					}
				}
			}
		}
		""";
	}

	private static List<string> GenerateTrimStatements(
		INamedTypeSymbol typeSymbol,
		string instanceName,
		HashSet<INamedTypeSymbol> visitedTypes,
		INamedTypeSymbol trimmableInterface,
		int depth)
	{
		var statements = new List<string>();

		if (visitedTypes.Contains(typeSymbol))
			return statements;

		_ = visitedTypes.Add(typeSymbol);

		foreach (var member in typeSymbol.GetMembers())
		{
			if (member is IPropertySymbol property &&
				property.SetMethod is not null &&
				!property.SetMethod.IsInitOnly &&
				property.GetMethod is not null &&
				property.DeclaredAccessibility is Accessibility.Public)
			{
				string propertyName = property.Name;
				var propertyType = property.Type;

				if (propertyType.SpecialType == SpecialType.System_String)
				{
					statements.Add($"if ({instanceName}.{propertyName} is not null)");
					statements.Add("{");
					statements.Add($"\t{instanceName}.{propertyName} = {instanceName}.{propertyName}.Trim();");
					statements.Add("}");
				}
				else if (propertyType is INamedTypeSymbol namedPropertyType &&
						 !IsSystemType(namedPropertyType) &&
						 !namedPropertyType.IsValueType)
				{
					if (ImplementsInterface(namedPropertyType, trimmableInterface))
					{
						statements.Add($"{instanceName}.{propertyName}?.TrimAllStringProperties();");
					}
					else
					{
						var nestedStatements = GenerateTrimStatements(
							namedPropertyType,
							$"{instanceName}.{propertyName}",
							visitedTypes,
							trimmableInterface,
							depth + 1);

						if (nestedStatements.Any())
						{
							statements.Add($"if ({instanceName}.{propertyName} is not null)");
							statements.Add("{");
							foreach (string statement in nestedStatements)
							{
								statements.Add($"\t{statement}");
							}

							statements.Add("}");
						}
					}
				}
				else if (IsDictionaryType(propertyType))
				{
					var (keyType, valueType) = GetDictionaryKeyValueTypes(propertyType);
					if (keyType is not null && valueType is not null)
					{
						// Handle dictionary with string keys
						if (keyType.SpecialType == SpecialType.System_String)
						{
							statements.Add($"if ({instanceName}.{propertyName} is not null)");
							statements.Add("{");
							statements.Add($"\tvar trimmedKeys{depth} = new System.Collections.Generic.Dictionary<string, dynamic>();");
							statements.Add($"\tforeach (var kvp{depth} in {instanceName}.{propertyName})");
							statements.Add("\t{");
							statements.Add($"\t\tstring trimmedKey{depth} = kvp{depth}.Key?.Trim() ?? kvp{depth}.Key;");
							statements.Add($"\t\ttrimmedKeys{depth}[trimmedKey{depth}] = kvp{depth}.Value;");
							statements.Add("\t}");
							statements.Add("");
							statements.Add($"\t// Clear and repopulate with trimmed keys");
							statements.Add($"\t{instanceName}.{propertyName}.Clear();");
							statements.Add($"\tforeach (var kvp{depth} in trimmedKeys{depth})");
							statements.Add("\t{");
							statements.Add($"\t\t{instanceName}.{propertyName}[kvp{depth}.Key] = kvp{depth}.Value;");
							statements.Add("\t}");
							statements.Add("}");
						}

						// Handle dictionary with string values
						if (valueType.SpecialType == SpecialType.System_String)
						{
							statements.Add($"if ({instanceName}.{propertyName} is not null)");
							statements.Add("{");
							statements.Add($"\tvar keys{depth} = {instanceName}.{propertyName}.Keys.ToArray();");
							statements.Add($"\tforeach (var key{depth} in keys{depth})");
							statements.Add("\t{");
							statements.Add($"\t\tif ({instanceName}.{propertyName}[key{depth}] is not null)");
							statements.Add("\t\t{");
							statements.Add($"\t\t\t{instanceName}.{propertyName}[key{depth}] = {instanceName}.{propertyName}[key{depth}].Trim();");
							statements.Add("\t\t}");
							statements.Add("\t}");
							statements.Add("}");
						}
						// Handle dictionary with object values implementing IUmbrellaTrimmable
						else if (valueType is INamedTypeSymbol namedValueType &&
								!IsSystemType(namedValueType) &&
								!namedValueType.IsValueType)
						{
							if (ImplementsInterface(namedValueType, trimmableInterface))
							{
								statements.Add($"if ({instanceName}.{propertyName} is not null)");
								statements.Add("{");
								statements.Add($"\tforeach (var value{depth} in {instanceName}.{propertyName}.Values)");
								statements.Add("\t{");
								statements.Add($"\t\tvalue{depth}?.TrimAllStringProperties();");
								statements.Add("\t}");
								statements.Add("}");
							}
							else
							{
								// Handle dictionary values that may contain string properties
								var valueStatements = GenerateTrimStatements(
									namedValueType,
									$"value{depth}",
									visitedTypes,
									trimmableInterface,
									depth + 1);

								if (valueStatements.Any())
								{
									statements.Add($"if ({instanceName}.{propertyName} is not null)");
									statements.Add("{");
									statements.Add($"\tforeach (var value{depth} in {instanceName}.{propertyName}.Values)");
									statements.Add("\t{");
									statements.Add($"\t\tif (value{depth} is not null)");
									statements.Add("\t\t{");
									
									foreach (string statement in valueStatements)
									{
										statements.Add($"\t\t\t{statement}");
									}

									statements.Add("\t\t}");
									statements.Add("\t}");
									statements.Add("}");
								}
							}
						}
					}
				}
				else if (IsCollectionType(propertyType))
				{
					var elementType = GetCollectionElementType(propertyType);
					if (elementType is not null)
					{
						if (elementType.SpecialType == SpecialType.System_String)
						{
							statements.Add($"if ({instanceName}.{propertyName} is not null)");
							statements.Add("{");
							statements.Add($"\tfor (int i{depth} = 0; i{depth} < {instanceName}.{propertyName}.Count; i{depth}++)");
							statements.Add("\t{");
							statements.Add($"\t\tif ({instanceName}.{propertyName}[i{depth}] is not null)");
							statements.Add("\t\t{");
							statements.Add($"\t\t\t{instanceName}.{propertyName}[i{depth}] = {instanceName}.{propertyName}[i{depth}].Trim();");
							statements.Add("\t\t}");
							statements.Add("\t}");
							statements.Add("}");
						}
						else if (elementType is INamedTypeSymbol namedElementType &&
								 !IsSystemType(namedElementType) &&
								 !namedElementType.IsValueType)
						{
							if (ImplementsInterface(namedElementType, trimmableInterface))
							{
								statements.Add($"if ({instanceName}.{propertyName} is not null)");
								statements.Add("{");
								statements.Add($"\tforeach (var item{depth} in {instanceName}.{propertyName})");
								statements.Add("\t{");
								statements.Add($"\t\titem{depth}?.TrimAllStringProperties();");
								statements.Add("\t}");
								statements.Add("}");
							}
							else
							{
								// Handle collections of non-IUmbrellaTrimmable types that may have string properties
								var collectionStatements = GenerateTrimStatements(
									namedElementType,
									$"item{depth}",
									visitedTypes,
									trimmableInterface,
									depth + 1);

								if (collectionStatements.Any())
								{
									statements.Add($"if ({instanceName}.{propertyName} is not null)");
									statements.Add("{");
									statements.Add($"\tforeach (var item{depth} in {instanceName}.{propertyName})");
									statements.Add("\t{");
									statements.Add($"\t\tif (item{depth} is not null)");
									statements.Add("\t\t{");
									
									foreach (string statement in collectionStatements)
									{
										statements.Add($"\t\t\t{statement}");
									}

									statements.Add("\t\t}");
									statements.Add("\t}");
									statements.Add("}");
								}
							}
						}
					}
				}
			}
		}

		_ = visitedTypes.Remove(typeSymbol);

		return statements;
	}

	private static bool IsSystemType(INamedTypeSymbol type)
	{
		string? namespaceName = type.ContainingNamespace?.ToDisplayString();

		return namespaceName?.StartsWith("System", StringComparison.Ordinal) is true ||
			   namespaceName?.StartsWith("Microsoft", StringComparison.Ordinal) is true;
	}

	private static bool IsDictionaryType(ITypeSymbol type)
	{
		if (type is INamedTypeSymbol namedType)
		{
			string[] dictionaryInterfaces =
			[
				"System.Collections.Generic.IDictionary",
					"System.Collections.Generic.IReadOnlyDictionary"
			];

			return namedType.AllInterfaces.Any(i =>
				dictionaryInterfaces.Any(di => i.ToDisplayString().StartsWith(di, StringComparison.Ordinal)));
		}

		return false;
	}

	private static (ITypeSymbol? KeyType, ITypeSymbol? ValueType) GetDictionaryKeyValueTypes(ITypeSymbol type)
	{
		if (type is INamedTypeSymbol namedType && namedType.TypeArguments.Length >= 2)
		{
			return (namedType.TypeArguments[0], namedType.TypeArguments[1]);
		}

		return (null, null);
	}

	private static bool IsCollectionType(ITypeSymbol type)
	{
		if (type is IArrayTypeSymbol)
			return true;

		if (type is INamedTypeSymbol namedType)
		{
			string[] collectionInterfaces =
			[
				"System.Collections.Generic.IList",
					"System.Collections.Generic.ICollection",
					"System.Collections.Generic.IEnumerable"
			];

			return namedType.AllInterfaces.Any(i =>
				collectionInterfaces.Any(ci => i.ToDisplayString().StartsWith(ci, StringComparison.Ordinal)));
		}

		return false;
	}

	private static ITypeSymbol? GetCollectionElementType(ITypeSymbol type)
	{
		if (type is IArrayTypeSymbol arrayType)
			return arrayType.ElementType;

		if (type is INamedTypeSymbol namedType && namedType.TypeArguments.Length > 0)
			return namedType.TypeArguments[0];

		return null;
	}
}