# StringTrimmer Source Generator

A C# source generator that automatically implements string property trimming for types implementing the `ITrimmable` interface using modern C# pattern matching and null propagation operators for maximum safety and performance.

## Features

- ‚ú® **Modern C# Syntax**: Uses `is not null` pattern matching and null propagation operators
- üîí **Operator Override Safety**: Robust against types that override equality operators
- üîÑ **Recursive Trimming**: Handles nested objects and collections
- üì¶ **Collection Support**: Trims strings in arrays, lists, and other collections
- ‚ö° **Performance Optimized**: Minimal conditional branching
- üõ°Ô∏è **Null Safe**: Comprehensive null checking without exceptions
- üîÅ **Circular Reference Protection**: Prevents infinite recursion

## Installation

```xml
<PackageReference Include="StringTrimmer.SourceGenerator" Version="1.2.0">
  <PrivateAssets>all</PrivateAssets>
  <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
</PackageReference>
```

## Generated Code Example

For this input:

```csharp
using StringTrimmer;

public partial class Person : ITrimmable
{
    public string? FirstName { get; set; }
    public string? LastName { get; set; }
    public Address? Address { get; set; }
    public ContactInfo? Contact { get; set; }
    public List<string>? Nicknames { get; set; }
    public List<Address>? PreviousAddresses { get; set; }
}

public partial class Address : ITrimmable
{
    public string? Street { get; set; }
    public string? City { get; set; }
}

public class ContactInfo
{
    public string? Email { get; set; }
    public string? Phone { get; set; }
}
```

The generator produces this robust code:

```csharp
// <auto-generated />
#nullable enable
using System;

namespace YourNamespace
{
    partial class Person
    {
        /// <summary>
        /// Trims all string properties in this object and its nested properties.
        /// Generated by StringTrimmer Source Generator.
        /// Uses modern C# pattern matching for robust null checking.
        /// </summary>
        public void TrimAllStringProperties()
        {
            FirstName = FirstName?.Trim();
            LastName = LastName?.Trim();
            Address?.TrimAllStringProperties();
            if (Contact is not null)
            {
                Contact.Email = Contact.Email?.Trim();
                Contact.Phone = Contact.Phone?.Trim();
            }
            if (Nicknames is not null)
            {
                for (int i = 0; i < Nicknames.Count; i++)
                {
                    Nicknames[i] = Nicknames[i]?.Trim();
                }
            }
            if (PreviousAddresses is not null)
            {
                foreach (var item in PreviousAddresses)
                {
                    item?.TrimAllStringProperties();
                }
            }
        }
    }
}
```

## Why Pattern Matching?

Using `is not null` instead of `!= null` provides several advantages:

### 1. **Operator Override Safety**

```csharp
// Problematic: Custom type that overrides operators
public class CustomType
{
    public static bool operator ==(CustomType left, CustomType right) => false; // Always false!
    public static bool operator !=(CustomType left, CustomType right) => true;  // Always true!
}

// With != null (UNSAFE):
if (obj != null) // This might call the overridden operator!

// With pattern matching (SAFE):
if (obj is not null) // This always does true null checking
```

### 2. **Performance Benefits**

- `is not null` compiles to direct null comparison instructions
- No virtual method calls or operator resolution
- Slightly faster execution with cleaner IL code

### 3. **Intent Clarity**

- `is not null` clearly expresses the intent to check for null reference
- More readable and maintainable code
- Follows modern C# best practices

## Requirements

- .NET Standard 2.0 or higher
- C# 9.0 or higher (for `is not null` pattern matching)
- Classes implementing `ITrimmable` must be declared as `partial`

## Advanced Features

### Collection Support

The generator handles various collection types:

```csharp
public partial class DataContainer : ITrimmable
{
    public string[]? StringArray { get; set; }
    public List<string>? StringList { get; set; }
    public IList<Address>? AddressList { get; set; }
    public ICollection<string>? StringCollection { get; set; }
}
```

### Nested ITrimmable Objects

When nested objects implement `ITrimmable`, the generator optimizes by calling their method:

```csharp
// Instead of generating inline trimming code:
Address?.TrimAllStringProperties(); // Clean and efficient

// Rather than:
if (Address is not null)
{
    Address.Street = Address.Street?.Trim();
    Address.City = Address.City?.Trim();
    // ... more properties
}
```

## Safety Guarantees

1. **Null Reference Safety**: All operations are null-safe
2. **Operator Override Protection**: Uses pattern matching instead of operators
3. **Circular Reference Detection**: Prevents infinite recursion
4. **Collection Bounds Safety**: Proper bounds checking for collections
5. **Exception Prevention**: No null reference exceptions during trimming

## Performance Characteristics

- **O(1)** for simple string properties
- **O(n)** for collections with n elements
- **O(d)** for nested objects with depth d
- Minimal memory allocations
- Optimized IL generation