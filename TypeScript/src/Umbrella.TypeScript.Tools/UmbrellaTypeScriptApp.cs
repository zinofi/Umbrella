// Copyright (c) Zinofi Digital Ltd. All Rights Reserved.
// Licensed under the MIT License.

using CommunityToolkit.Diagnostics;
using Microsoft.Extensions.CommandLineUtils;
using System.Reflection;
using System.Runtime.Loader;
using System.Text;
using System.Text.Json;

namespace Umbrella.TypeScript.Tools;

public class UmbrellaTypeScriptApp : UmbrellaTypeScriptApp<ToolOptions>
{
}

public class UmbrellaTypeScriptApp<TOptions> : CommandLineApplication
	where TOptions : ToolOptions, new()
{
	protected ConsoleColor InitialConsoleColor { get; } = Console.ForegroundColor;
	protected Dictionary<string, CommandOption>? OptionDictionary { get; private set; }

	public UmbrellaTypeScriptApp()
	{
		Name = "dotnet-umbrella-ts";
		FullName = ".NET Core Umbrella TypeScript Generator";
		Description = "TypeScript generator for .NET Core applications";

		_ = HelpOption("-?|-h|--help");

		SetupCommandOptions();

		OnExecute(() =>
		{
			TOptions toolOptions = GetToolOptions();

			if (toolOptions.DebugEnabled)
			{
				WriteConsoleDebugMessage($"Parsed options: {JsonSerializer.Serialize(toolOptions)}");
			}

			//Check folder exists
			if (!Directory.Exists(toolOptions.AssemblyFolderPath))
			{
				WriteConsoleErrorMessage($"The path for the --input|-i argument {toolOptions.AssemblyFolderPath} does not exist.");
				return 3;
			}

			//Load Runtime Assemblies
			_ = UmbrellaTypeScriptApp<TOptions>.LoadAssemblies(toolOptions.AssemblyFolderPath, toolOptions.RuntimeAssemblyNameList);

			//Assemblies to scan
			List<Assembly> lstAssemblyToProcess = UmbrellaTypeScriptApp<TOptions>.LoadAssemblies(toolOptions.AssemblyFolderPath, toolOptions.AssemblyNameList);

			if (lstAssemblyToProcess.Count == 0)
			{
				WriteConsoleErrorMessage($"No assemblies were loaded to process.");
				return 3;
			}

			var generator = new TypeScriptGenerator(lstAssemblyToProcess);

			SetupGenerators(generator, toolOptions);

			Guard.IsNotNull(generator.Generators, "--generators|-g");
			Guard.IsGreaterThan(generator.Generators.Count, 0, "--generators|-g");

			string strOutput = generator.GenerateAll(toolOptions.OutputType == "module", toolOptions.StrictNullChecks, toolOptions.PropertyMode);
			StringBuilder sbOutput = CreateOutputBuilder(toolOptions);

			_ = sbOutput.AppendLine(strOutput);

			using StreamWriter sw = File.CreateText(toolOptions.OutputPath!);
			
			sw.Write(sbOutput.ToString());

			return 0;
		});
	}

	public void WriteConsoleErrorMessage(string message)
	{
		Console.ForegroundColor = ConsoleColor.Red;
		Console.Error.WriteLine(message);
		Console.ForegroundColor = InitialConsoleColor;
	}

	public void WriteConsoleDebugMessage(string message) => WriteColoredConsoleMessage(message, ConsoleColor.Yellow);

	public void WriteConsoleInfoMessage(string message) => WriteColoredConsoleMessage(message, ConsoleColor.Cyan);

	protected virtual StringBuilder CreateOutputBuilder(TOptions toolOptions)
	{
		Guard.IsNotNull(toolOptions);

		var builder = new StringBuilder()
			.AppendLine("/* eslint-disable */")
			.AppendLine("//------------------------------------------------------------------------------")
			.AppendLine("// <auto-generated>")
			.AppendLine("//")
			.AppendLine("// This code has been automatically generated by a tool. Any changes made to")
			.AppendLine("// this file will be overwritten the next time the tool is run.")
			.AppendLine("//")
			.AppendLine("// </auto-generated>")
			.AppendLine("//------------------------------------------------------------------------------");

		if (toolOptions.GeneratorList?.Contains("knockout") is true)
		{
			if (toolOptions.OutputType == "module")
			{
				_ = builder.AppendLine("import * as ko from \"knockout\";");

				if (toolOptions.ValidationEnabled)
				{
					_ = builder.AppendLine("import \"knockout.validation\";");
				}

				if (toolOptions.KnockoutUseDecorators)
				{
					_ = builder.AppendLine("import { observable, extend } from \"knockout-decorators\";");
				}
			}
			else
			{
				if (toolOptions.KnockoutUseDecorators)
				{
					_ = builder.AppendLine("const { observable, extend } = KnockoutDecorators;");
				}
			}

			_ = builder.AppendLine();
		}

		return builder;
	}

	protected virtual void SetupGenerators(TypeScriptGenerator generator, TOptions options)
	{
		Guard.IsNotNull(generator);
		Guard.IsNotNull(options);

		if (options.GeneratorList?.Contains("standard") is true)
		{
			_ = generator.IncludeStandardGenerators();
		}

		if (options.GeneratorList?.Contains("knockout") is true)
		{
			_ = generator.IncludeKnockoutGenerators(options.KnockoutUseDecorators);
		}
	}

	protected virtual void SetupCommandOptions()
	{
		CommandOption coVerbose = Option("--verbose|-v", "Show detailed output messages.", CommandOptionType.NoValue);
		CommandOption coDebug = Option("--debug|-d", "Show debug messages.", CommandOptionType.NoValue);

		CommandOption coAssemblyFolderPath = Option("--input|-i", "The physical path to the folder containing the assemblies to scan for TypeScript attributes.", CommandOptionType.SingleValue);
		CommandOption coAssemblyNames = Option("--assemblies|-a", "The names of the assemblies to scan for attributes. If not supplied all assemblies in the folder path will be scanned.", CommandOptionType.MultipleValue);
		CommandOption coRuntimeAssemblies = Option("--runtime-assemblies|-r", "The names of the assemblies to load into memory upon which the assemblies being scanned depend.", CommandOptionType.MultipleValue);
		CommandOption coGenerators = Option("--generators|-g", "The generators to include: [standard | knockout].", CommandOptionType.MultipleValue);
		CommandOption coOutputType = Option("--type|-t", "The output type: [namespace, module]", CommandOptionType.SingleValue);
		CommandOption coStrictNullChecks = Option("--strict|-s", "Enable strict null checks", CommandOptionType.NoValue);
		CommandOption coPropertyMode = Option("--property-mode|-p", "The TypeScriptPropertyMode to use: [None, Null, Model]. This value is case sensitive.", CommandOptionType.SingleValue);
		CommandOption coOutputPath = Option("--output|-o", "The path where the output file will be written.", CommandOptionType.SingleValue);
		CommandOption coKnockoutGenerators = Option("--knockout-decorators", "Specifies that generated Knockout types will use decorators instead of explicit observables.", CommandOptionType.NoValue);

		OptionDictionary = new Dictionary<string, CommandOption>
		{
			["verbose"] = coVerbose,
			["debug"] = coDebug,
			["input"] = coAssemblyFolderPath,
			["assemblies"] = coAssemblyNames,
			["runtime-assemblies"] = coRuntimeAssemblies,
			["generators"] = coGenerators,
			["type"] = coOutputType,
			["strict"] = coStrictNullChecks,
			["property-mode"] = coPropertyMode,
			["output"] = coOutputPath,
			["knockout-decorators"] = coKnockoutGenerators
		};

		OptionDictionary.Add("validation", Option("--validation", "Specify this flag to enable validation dependencies to be included.", CommandOptionType.NoValue));
	}

	protected virtual TOptions GetToolOptions()
	{
		Guard.IsNotNull(OptionDictionary);

		string propertyMode = UmbrellaTypeScriptApp<TOptions>.CleanInput(OptionDictionary["property-mode"].Value());

		if (!Enum.TryParse(propertyMode, out TypeScriptPropertyMode tsPropertyMode))
		{
			string message = $"The value for the --property-mode|-p argument {propertyMode} is invalid.";

			WriteConsoleErrorMessage(message);

			throw new InvalidOperationException(message);
		}

		var toolOptions = new TOptions
		{
			VerboseEnabled = OptionDictionary["verbose"].HasValue(),
			DebugEnabled = OptionDictionary["debug"].HasValue(),
			AssemblyFolderPath = UmbrellaTypeScriptApp<TOptions>.CleanInput(OptionDictionary["input"].Value()),
			AssemblyNameList = UmbrellaTypeScriptApp<TOptions>.CleanInput(OptionDictionary["assemblies"].Values),
			RuntimeAssemblyNameList = UmbrellaTypeScriptApp<TOptions>.CleanInput(OptionDictionary["runtime-assemblies"].Values),
			GeneratorList = UmbrellaTypeScriptApp<TOptions>.CleanInput(OptionDictionary["generators"].Values),
			OutputType = UmbrellaTypeScriptApp<TOptions>.CleanInput(OptionDictionary["type"].Value()),
			StrictNullChecks = OptionDictionary["strict"].HasValue(),
			PropertyMode = tsPropertyMode,
			OutputPath = UmbrellaTypeScriptApp<TOptions>.CleanInput(OptionDictionary["output"].Value()),
			KnockoutUseDecorators = OptionDictionary["knockout-decorators"].HasValue(),
			ValidationEnabled = OptionDictionary["validation"].HasValue()
		};

		Guard.IsNotNullOrWhiteSpace(toolOptions.AssemblyFolderPath, "--input|-i");
		Guard.IsNotNull(toolOptions.AssemblyNameList, "--assemblies|-a");
		Guard.HasSizeGreaterThan(toolOptions.AssemblyNameList, 0, "--assemblies|-a");
		Guard.IsNotNullOrWhiteSpace(toolOptions.OutputType, "--type|-t");
		Guard.IsNotNullOrWhiteSpace(toolOptions.OutputPath, "--output|-o");

		return toolOptions;
	}

	private void WriteColoredConsoleMessage(string message, ConsoleColor color)
	{
		Console.ForegroundColor = color;
		Console.WriteLine(message);
		Console.ForegroundColor = InitialConsoleColor;
	}

	private static List<string> CleanInput(List<string>? values) => values?.Select(x => x.Trim('"')).ToList() ?? [];

	private static string CleanInput(string input) => input?.Trim('"') ?? "";

	private static List<Assembly> LoadAssemblies(string? assemblyFolderPath, List<string>? lstAssemblyName)
	{
		Guard.IsNotNullOrWhiteSpace(assemblyFolderPath, nameof(assemblyFolderPath));
		Guard.IsNotNull(lstAssemblyName, nameof(lstAssemblyName));

		var lstAssemblyToProcess = new List<Assembly>();

		foreach (string assemblyName in lstAssemblyName!)
		{
			string fileName = Path.Combine(assemblyFolderPath!, $"{assemblyName}.dll");

			var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(fileName);

			lstAssemblyToProcess.Add(assembly);
		}

		return lstAssemblyToProcess;
	}
}